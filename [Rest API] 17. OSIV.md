# 1. OSIV

<br><Br>

JPA에서 EntityManager가 하이버네이트 에서는 Session이라고 한다.

여기서 말하는 Session이란 사용자의 데이터를 저장해주는 곳이 아니다.

<br><Br>

따라서 OSIV(Open Session In View) 는 하이버네이트,

OEIV(Open EntityManager In View) 는 JPA에서 사용된다.

OSIV는 말 그대로 영속성 컨텍스트를 뷰 까지 열어두는 기능이다.

`Spring.jpa.open-in.view`는 기본값이 True이다. 

<br><Br>

## 1)True

해당 값을 True로 하게 되면 트랜젝션 시작 시점에 DB와 커넥션을 맺는 영속성 컨텍스트가 생성되고 API응답이 끝날 때까지 영속성 컨텍스트와 DB커넥션을 유지한다. 따라서 지금까지 View Template이나 API Controller에서 지연로딩이 가능하였떤 것이다.

지연로딩은 프록시 객체를 초기화 하기 위해 영속성 컨텍스트가 필요하기 때문이다.

하지만 해당 전략은 너무 오랜시간 DB커넥션 리소스를 사용하기 때문에 실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 부족해질 수 있다. 

예를 들어서 컨트롤러에서 외부 API를 호출하게 되면 외부 API대기 시간만큼 커넥션 리소스를 반환하지 못하고, 유지해야 한다.

<br><Br>

## 2) False

해당 기능을 False로 설정하면 트랜잭션 종료 시점에 영속성 컨텍스트와 DB커넥션을 반환한다. 따라서 리소스를 낭비하지 않는다는 장점이 있다.

하지만 앞서 말했듯이 API Controller와 View Template에서는 지연로딩을 위해 해당 기능이 필요했었다.

해당 기능을 끄게 되면 컨트롤러와 뷰에서 지연로딩이 되지 않기 때문에 트랜잭션내부에서 지연로딩을 강제로 호출해야 하는 단점이 있다.

<br><Br>

## 3) 커맨드와 쿼리 분리

실무에서는 OSIV를 끈 상태로 복잡성을 관리하는 방법이 있다. 바로 커맨드와 쿼리를 분리하는 것이다.

<br><Br>

보통 핵심 비지니스 로직은 성능이 크게 문제 되지 않는다. 그런데 복잡한 화면을 출력하기 위한 쿼리는 화면에 맞추어 최적화 하는 것이 중요하다. 하지만 그 복잡성에 비해 핵심 비지니스에 큰 영향을 주는 것은 아니다. 

따라서 크고 복잡한 애플리케이션을 개발한다면, 이 둘의 관심사를 분리하는 것이 유지보수 관점에서 좋다.

예를들어 다음과 같이 분리하는 것이다

- OrderService
    - OrderService: 핵심 비지니스 로직
    - OrderQueryService: 화면이나 API에 맞춘 서비스(주로 읽기 전용 트랜잭션 사용)

<br><Br>

## 4) OSIV 꺼야할까, 켜야할까?

고객 서비스의 실시간 API는 OSIV를 끄고, ADMIN 처럼 커넥션을 많이 사용하지 않는 곳에서는 OSIV를 켠다.

